import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

##---------------------------------------------------блок переменных----------------------------------------------------------
k=4000
tau=15
t=[0]*k
n=[0]*k
##-----------------------------------------------конец блока переменных-------------------------------------------------------------------------



##----------------------------------------------------блок функций--------------------------------------------------------------------------------------
##факториал числа q
def fact(q):
    rez=1
    for i in range(1,q+1):
        rez*=i
    return rez

##выборочное среднее (сумма элементов деленая на их количество)
def selmid(nn):
    a=np.array(nn)
    return sum(a)/len(a)


##количество зарегестрированных частиц за t=tau
def taumid(k,a,tau):
    t=[]
    n=[]
    if k%tau!=0: ##если количество измерений не кратно tau, то обрезаем промежуток, 
        k-=tau   ##который рассматриваем на tau, чтобыне выпасть за пределы массива
    for i in range(1,k,tau): ##моральные уроды в любом случае теряют tau значений, но так как я хочу попасть в графики, которые выдает установка, буду страдать
        t.append(i) ##создаю точку на оси абсцисс
        count=0 ##накопительный счетчик для данного отрезка tau
        for j in range(tau):
            count+=a[i+j-1]##выцепляю и суммирую значения из данного отрезка tau
        n.append(count)##сохраняю значения tau
        k=np.array(n)##просто для приятностей
##        k+=1
    return t,k


##вероятность выпадения этого количества частиц
##(на вход накопленные значения из taumid)        
def probabilitynum(a):
    mx=max(a)##находим максимальное значение, которое было собрано за tau
    num=[0.0]*(mx+1)
    value=np.array([0.0]*(mx+1))
    for i in range(mx+1):##пробегаемся по всем числам и создаем ось абсцисс
        num[i]=i
    for i in range(len(a)):##бежим по всем элементам входного массива
        value[a[i]]+=1     ##находим количество одинаковых элементов и заносим их количество в соответсвенную ячейку
    value=value/sum(value) ##переводим в доли, чтобы площадь под гистограммой равнялась 1
    return num, value

##распределение Пуассона
def Puasson(probnum, taunum):
    num=[]
    fnum=[]
    for i in range(len(probnum)+1):##будем отображать распределение Пуассона только в области определения заданной от нуля до максимального количества элементов
        num.append(i)##задаем ось абсцисс
        fct=fact(i)##ищем факториал числа в данной точке
        smid=selmid(taunum)##ищем выборочное среднее для данной группировке по tau
        e=2.718281828459045##помним наизусть много циферок Эйлерового числа
        y=(smid**i)*e**(-smid)/fct##находим значение распределения Пуассона в данной точке
        fnum.append(y)##гордо сохраняем значение 
    return num,fnum
##-------------------------------------------------конец блока функций--------------------------------------------------------------------------------------
        
    
##----------------------------------------------------блок main--------------------------------------------------------------------------------------
file = open('1.1.4.txt', 'r')
for i in range(1,k+1):
    n[i-1]=int(file.readline()[:-1:])
rez=taumid(k,n,tau)
rezp=probabilitynum(rez[1])
puassonfig=Puasson(rezp[1], rez[1])
plt.bar(rezp[0],rezp[1],width=1)
plt.plot(puassonfig[0], puassonfig[1], color='blue', linewidth=2)
##plt.hist(rezp[1], width=0.5)
##print(rez)

plt.grid(True, which='major', linestyle='-')#мажорная сетка
plt.grid(True, which='minor', linestyle='--', linewidth=0.5)#минорная сетка
plt.minorticks_on()
plt.show()
##-------------------------------------------------конец блока main--------------------------------------------------------------------------------------
        

